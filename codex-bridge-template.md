# CODEX.md — GSD Bridge v2 Instructions

> Place this file at your project root as `CODEX.md` so Codex reads it automatically.

## Project Overview

This project uses a dual-agent workflow:
- **Claude Code (GSD framework)** handles planning, roadmapping, and architecture
- **Codex (superpowers framework)** handles execution of those plans
- **GSD Bridge v2** connects them with canonical state, a manifest entrypoint, and drift detection

## Architecture

```
.planning/                          # GSD source (READ-ONLY — never modify)
├── ROADMAP.md
├── STATE.md
├── PROJECT.md
└── phases/
    └── XX-phase-name/
        ├── XX-NN-PLAN.md           # Source plans (GSD format)
        ├── XX-NN-SUMMARY.md        # Execution records
        ├── XX-CONTEXT.md           # Strategic context
        └── XX-RESEARCH.md          # Research findings

docs/plans/                         # Bridge output (YOUR execution space)
├── _manifest.json                  # THE entrypoint — ordered plan list
├── _state/                         # Canonical state per plan (YOU own this)
│   └── <plan_id>.json
├── _blockers/                      # Blocker notes (write when blocked)
│   └── <plan_id>.md
├── _logs/                          # Execution logs
│   └── <plan_id>/
├── STATUS.md                       # Dashboard (generated by reconcile)
└── <plan_id>.md                    # Converted plans
```

## How to Execute

### 1. Read the manifest

```bash
cat docs/plans/_manifest.json
```

The manifest is ordered by wave → phase → plan. Execute plans in this order.

### 2. Pick the next pending plan

Look for the first entry where `"status": "pending"`. The plan's converted markdown is at the `plan_path` field.

### 3. Pre-flight checks

Before starting any plan:
- **Check state file**: Read `docs/plans/_state/<plan_id>.json`
  - If `status` is `executing` → another session may be running. Stop.
  - If `source_plan_hash` doesn't match the source file → drift detected. Stop. Re-export needed.
- **Check execution contract** (if present in the plan):
  - Verify all required env vars are set
  - Verify required services are running
  - Verify prerequisite plans are `verified`

### 4. Start execution

Update the state file:
```json
{
  "status": "executing",
  "last_run_at": "<ISO-8601 timestamp>",
  "executor": {
    "tool": "codex",
    "model": "<model-name>",
    "run_id": "<session-id>"
  }
}
```

Or use the Python adapter:
```python
from gsd_bridge.codex_adapter import start_execution
start_execution(Path("docs/plans/_state/<plan_id>.json"), {
    "tool": "codex", "model": "o3", "run_id": "session-123"
})
```

### 5. Execute tasks in batches

The plan specifies its batch size (default: 3). Execute that many tasks, then pause for review.

After each task:
- Run the task's verification (quick tier first, then full)
- Commit the task separately: `feat(phase-XX): task N - description`
- Update state: add task number to `completed_tasks`

### 6. Run verification tiers

Plans have up to three verification tiers:
1. **Quick** — grep, tsc, lint (seconds)
2. **Full** — build, test suites (minutes)
3. **Smoke** — runtime checks, lighthouse (requires running server)

Run quick and full after each batch. Smoke runs after all tasks complete.

Record each result in the state file:
```json
{
  "verification": {
    "quick": [
      { "command": "npx tsc --noEmit", "exit_code": 0, "log_path": "docs/plans/_logs/<plan_id>/quick-...log" },
      { "command": "npx eslint .", "exit_code": 0, "log_path": "docs/plans/_logs/<plan_id>/quick-...log" }
    ],
    "full": [
      { "command": "npx next build", "exit_code": 0, "log_path": "docs/plans/_logs/<plan_id>/full-...log" }
    ]
  }
}
```

### 7. Complete or fail

- **All verification passes**: Set `status` → `verified`
- **Verification fails**: Set `status` → `failed` with reason in `failure_reason`
- **Missing info/env/blocked**: Set `status` → `blocked` and write a blocker file

### 8. Move to next plan

Return to step 2 and pick the next pending plan.

## Rules

1. **Manifest is the entrypoint** — do not scan `docs/plans/` for files. Use `_manifest.json`.
2. **State files are the source of truth** — not SUMMARY.md, not checkboxes.
3. **Never modify `.planning/` files** — those are managed by Claude Code/GSD.
4. **Stop on drift** — if `source_plan_hash` doesn't match, request re-export.
5. **Stop on verification failure** — do not proceed past a failing check.
6. **Respect wave ordering** — lower wave numbers must complete (status: verified) before higher ones.
7. **One executor at a time** — if state says `executing`, do not start a second session.
8. **Write blockers** — if blocked, always write `docs/plans/_blockers/<plan_id>.md` with what's missing.
9. **Commit per task** — format: `feat(phase-XX): task N - description`

## Blocked Protocol

When you can't proceed:

1. Set state to `blocked`:
   ```json
   { "status": "blocked", "blocked_reason": "Missing HUBSPOT_API_KEY env var" }
   ```

2. Write a blocker file at `docs/plans/_blockers/<plan_id>.md`:
   ```markdown
   # Blocked: <plan_id>

   ## What's blocked
   Cannot run HubSpot integration tests — HUBSPOT_API_KEY not set.

   ## Missing information
   Need the HubSpot API key for the staging environment.

   ## To unblock
   export HUBSPOT_API_KEY=<your-key>
   python -m gsd_bridge adapter resume docs/plans/_state/<plan_id>.json
   ```

3. Stop. Do not attempt workarounds.

## Drift Detection

If you detect that a source plan has changed (hash mismatch):
- Set state to `failed` with reason `"source plan drift detected"`
- Do NOT continue executing the old version
- Request a re-export: `python -m gsd_bridge export .planning/ --pending`

## Re-exporting Plans

When GSD creates or modifies plans:

```bash
# Export all pending plans
python -m gsd_bridge export .planning/ --pending -o docs/plans/

# Check status
python -m gsd_bridge status docs/plans/

# Sync manifest status from state files only
python -m gsd_bridge refresh docs/plans/

# After execution, reconcile
python -m gsd_bridge reconcile docs/plans/
```

## Context Files

When executing a plan, you may need context from GSD:

- **`.planning/phases/XX-name/XX-CONTEXT.md`** — Strategic decisions, locked constraints
- **`.planning/phases/XX-name/XX-RESEARCH.md`** — Technical research, patterns
- **`.planning/PROJECT.md`** — Core requirements, architecture
- **`.planning/codebase/`** — Codebase analysis documents

Read the relevant CONTEXT.md before starting a phase.
